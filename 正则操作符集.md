# 正则法则 操作符和操作元 归纳

**一切都是字符串**

>编程是语言无非是用来运算（需要操作符和操作元）的 正则规则Regex 本身就是个迷你语言

**字符串最小单位-原子** 

>就是本义字符（他们代表的就是他们的字面值）  都是单个字符
* 本义字符：a-z A-Z 0-9 _ 

**{特殊含义}字符**

 >没带转义符的单个含义 （如果想使用以下特殊字符时前面加上转义符\ 如\$ \< 
 * \ (转义符) 
* .  （类别原子：除\r \n 之外的任意字符=[^\n \r]）          
* ^ $ （定位标符： 开始-结束   在集合原子中[^abc] :排除）
* \+   \*   ? （这3都是操作前面的原（元）子）
* \-  |       （在集合原子中[ a-z ]: 区间   ( a|z ) :分段  | 没有集合时：或）
* (  )   [  ]  {  }  （一对使用表示把原子集合起来） 
* <   >     

**类别原子**
>代表"一类字符"的原子
* \\d 任意数字=[0-9]
* \\D 任意非数字=[^0-9]
* \\w 任意本义字符=[a-zA-Z0-9_]
* \\W 任意非本义字符=[^a-zA-Z0-9_]  
* \\s 任意空白=[ \f \n \r \t \v ]   注意：方括号内第一个字符是空格符号
* \\S 任意非空白=[ ^\f \n \r \t \v ]  注意：方括号内第一个字符是空格符号  
* \.   除\r \n 之外的任意字符=[^\n \r]  

* \\d ：digits 数字
* \\w ：word characters 本义字符
* \\s ：spaces 空白

* \\f ：flip 分页符

* \\n ：new line 换行符
* \\r ：return 换行符
* \\t ：tab     制表符
* \\v ：vertical ta 纵向制表符 

**边界原子**
>定位操作符
* \^ 匹配被搜索字符串的开始位置；
* \$ 匹配被搜索字符串的结束位置；
* \\b 匹配单词的边界；er\b，能匹配 coder 中的 er，却不能匹配 error 中的 er；
* \\B 匹配非单词边界；er\B，能匹配 error 中的 er，却不能匹配 coder 中的 er。

**组合原子**
* 用圆括号 () 将多个单字符原子组合成一个原子
* 这么做的效果是 () 内的字符串将被当作一整个原子，
* 这个语法叫做分组或者组合（grouping）。可以被随后我们要讲解的数量操作符操作。

**数量操作符**
>数量操作符有这几个：+ ? * {n, m}。
* \+  代表前面的原子必须至少出现一次，即 出现次数 ≧ 1 
* \?  代表前面的原子最多只可以出现一次，即 0 ≦ 出现次数 ≦ 1
* \*  代表前面的原子可以不出现，也可以出现一次或者多次
* \{n}     代表前面的原子确定出现 n 次
* \{n, m}  代表前面的原子出现至少 n 次，至多 m 次 

# 要注意区别
>er、[er] 和 (er) 各不相同。

* er 是两个原子，'e' 之后 'r'
* [er] 是一个原子，或者 'e' 或者 'r'；
* (er) 是一个原子，'er'\n ：new line 换行符
* \\r ：return 换行符
* \\t ：tab     制表符
* \\v ：vertical ta 纵向制表符 

